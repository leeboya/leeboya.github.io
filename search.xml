<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[JavaScript构造函数及原型对象]]></title>
      <url>%2F2017%2F04%2F01%2FJavaScript%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[JavaScript构造函数及原型对象JavaScript中没有类的概念，所以其在对象创建方面与面向对象语音有所不同。 JS中对象可以定义为”无序属性的集合”。其属性可以包含基本值，对象以及函数。对象实质上就是一组没有特定顺序的值，对象中每个属性、方法都有一个名字，每个名字都映射到了一个值，因此我们可以将对象想象称为一个散列表。 JS是一种基于对象的语言，对象的概念在JS体系中十分的重要，因此有必要清楚地了解一下JS中对象创建的常用方法及各自的局限性。 使用Object或对象字面量创建对象在说工厂模式创建对象之前，我们不妨回顾一下JS中最基本的创建对象的方法，比如说我想创建一个student对象怎么办？最简单地，new一个Object： 123var student = new Object();student.name = &quot;easy&quot;;student.age = &quot;20&quot;; 这样，一个student对象就创建完毕，拥有2个属性name以及age，分别赋值为”easy”和20。 如果你嫌这种方法有一种封装性不良的感觉，我们也可以使用对象字面量的方式来创建student对象： 1234var sutdent = &#123; name : &quot;easy&quot;, age : 20&#125;; 这样看起来似乎就完美了。但是马上我们就会发现一个十分尖锐的问题：当我们要创建同类的student1，student2，…，studentn时，我们不得不将以上的代码重复n次。 12345678910111213141516 var sutdent1 = &#123; name : &quot;easy1&quot;, age : 20 &#125;; var sutdent2 = &#123; name : &quot;easy2&quot;, age : 20 &#125;;//... var sutdentn = &#123; name : &quot;easyn&quot;, age : 20 &#125;; 能不能像工厂车间那样，有一个车床就不断生产出对象呢？我们看”工厂模式”。 工厂模式创建对象JS中没有类的概念，那么我们不妨就使用一种函数将以上对象创建过程封装起来以便于重复调用，同时可以给出特定接口来初始化对象： 1234567891011function createStudent(name, age) &#123; var obj = new Object(); obj.name = name; obj.age = age; return obj;&#125;var student1 = createStudent(&quot;easy1&quot;, 20);var student2 = createStudent(&quot;easy2&quot;, 20);//...var studentn = createStudent(&quot;easyn&quot;, 20); 这样一来我们就可以通过createStudent函数源源不断地”生产”对象了。看起来已经高枕无忧了，但贪婪的人类总有不满足于现状的天性：我们不仅希望”产品”的生产可以像工厂车间一般源源不断，我们还想知道生产的产品究竟是哪一种类型的。 比如说，我们同时又定义了”生产”水果对象的createFruit()函数： 123456789function createFruit(name, color) &#123; var obj = new Object(); obj.name = name; obj.color = color; return obj;&#125;var v1 = createStudent(&quot;easy1&quot;, 20);var v2 = createFruit(&quot;apple&quot;, &quot;green&quot;); 对于以上代码创建的对象v1、v2，我们用instanceof操作符去检测，他们统统都是Object类型。我们的当然不满足于此，我们希望v1是Student类型的，而v2是Fruit类型的。为了实现这个目标，我们可以用自定义构造函数的方法来创建对象。 构造函数模式创建对象在上面创建Object这样的原生对象的时候，我们就使用过其构造函数： 1var obj = new Object(); 在创建原生数组Array类型对象时也使用过其构造函数： 1var arr = new Array(10); //构造一个初始长度为10的数组对象 在进行自定义构造函数创建对象之前，我们首先了解一下构造函数和普通函数有什么区别。 其一，实际上并不存在创建构造函数的特殊语法，其与普通函数唯一的区别在于调用方法。对于任意函数，使用new操作符调用，那么它就是构造函数；不使用new操作符调用，那么它就是普通函数。 其二，按照惯例，我们约定构造函数名以大写字母开头，普通函数以小写字母开头，这样有利于显性区分二者。例如上面的new Array()，new Object()。 其三，使用new操作符调用构造函数时，会经历(1)创建一个新对象；(2)将构造函数作用域赋给新对象（使this指向该新对象）；(3)执行构造函数代码；(4)返回新对象；4个阶段。 了解了构造函数和普通函数的区别之后，我们使用构造函数将工厂模式的函数重写，并添加一个方法属性： 123456789101112131415161718192021222324252627282930function Student(name, age) &#123; this.name = name; this.age = age; this.alertName = function()&#123; alert(this.name) &#125;;&#125;function Fruit(name, color) &#123; this.name = name; this.color = color; this.alertName = function()&#123; alert(this.name) &#125;;&#125;//这样我们再分别创建Student和Fruit的对象：var v1 = new Student(&quot;easy&quot;, 20);var v2 = new Fruit(&quot;apple&quot;, &quot;green&quot;);//这时我们再来用instanceof操作符来检测以上对象类型就可以区分出Student以及Fruit了：alert(v1 instanceof Student); //truealert(v2 instanceof Student); //falsealert(v1 instanceof Fruit); //falsealert(v2 instanceof Fruit); //truealert(v1 instanceof Object); //true 任何对象均继承自Objectalert(v2 instanceof Object); //true 任何对象均继承自Object 这样我们就解决了工厂模式无法区分对象类型的尴尬。那么使用构造方法来创建对象是否已经完美了呢？ 我们知道在JS中，函数是对象。那么，当我们实例化不止一个Student对象的时候： 1234var v1 = new Student(&quot;easy1&quot;, 20);var v2 = new Student(&quot;easy2&quot;, 20);//...var vn = new Student(&quot;easyn&quot;, 20); 其中共同的alertName()函数也被实例化了n次，我们可以用以下方法来检测不同的Student对象并不共用alertName()函数： 1alert(v1.alertName == v2.alertName); //flase 这无疑是一种内存的浪费。我们知道，this对象是在运行时基于函数的执行环境进行绑定的。在全局函数中，this对象等同于window；在对象方法中，this指向该对象。在上面的构造函数中： 123this.alertName = function()&#123; alert(this.name) &#125;; 我们在创建对象（执行alertName函数之前）时，就将alertName()函数绑定在了该对象上。我们完全可以在执行该函数的时候再这样做，办法是将对象方法移到构造函数外部： 123456789101112function Student(name, age) &#123; this.name = name; this.age = age; this.alertName = alertName;&#125;function alertName() &#123; alert(this.name);&#125;var stu1 = new Student(&quot;easy1&quot;, 20);var stu2 = new Student(&quot;easy2&quot;, 20); 在调用stu1.alert()时，this对象才被绑定到stu1上。 我们通过将alertName()函数定义为全局函数，这样对象中的alertName属性则被设置为指向该全局函数的指针。由此stu1和stu2共享了该全局函数，解决了内存浪费的问题。 但是，通过全局函数的方式解决对象内部共享的问题，终究不像一个好的解决方法。如果这样定义的全局函数多了，我们想要将自定义对象封装的初衷便几乎无法实现了。更好的方案是通过原型对象模式来解决。 原型模式创建对象函数的原型对象在了解如何使用原型模式创建对象之前，有必要先搞清楚什么是原型对象。 我们创建的每一个函数都有一个prototype属性，该属性是一个指针，该指针指向了一个对象。对于我们创建的构造函数，该对象中包含可以由所有实例共享的属性和方法。如下如所示： 在默认情况下，所有原型对象会自动包含一个constructor属性，该属性也是一个指针，指向prototype所在的函数： 对象实例和原型对象的关联在调用构造函数创建新的实例时，该实例的内部会自动包含一个[[Prototype]]指针属性，该指针指便指向构造函数的原型对象。注意，这个指针关联的是实例与构造函数的原型对象而不是实例与构造函数： 使用原型模型创建对象直接在原型对象中添加属性和方法 了解了原型对象之后，我们便可以通过在构造函数原型对象中添加属性和方法来实现对象间数据的共享了。例如： 12345678910111213141516function Student() &#123;&#125;Student.prototype.name = &quot;easy&quot;;Student.prototype.age = 20;Student.prototype.alertName = function()&#123; alert(this.name);&#125;;var stu1 = new Student();var stu2 = new Student();stu1.alertName(); //easystu2.alertName(); //easyalert(stu1.alertName == stu2.alertName); //true 二者共享同一函数 以上代码，我们在Student的protptype对象中添加了name、age属性以及alertName()方法。但创建的stu1和stu2中并不包含name、age属性以及alertName()方法，而只包含一个[[prototype]]指针属性。当我们调用stu1.name或stu1.alertName()时，是如何找到对应的属性和方法的呢？ 当我们需要读取对象的某个属性时，都会执行一次搜索。首先在该对象中查找该属性，若找到，返回该属性值；否则，到[[prototype]]指向的原型对象中继续查找。 由此我们也可以看出另外一层意思：如果对象实例中包含和原型对象中同名的属性或方法，则对象实例中的该同名属性或方法会屏蔽原型对象中的同名属性或方法。原因就是“首先在该对象中查找该属性，若找到，返回该属性值；” 拥有同名实例属性或方法的示意图： 上图中，我们在访问stu1.name是会得到”EasySir”： 1alert(stu1.name); //EasySir` 通过对象字面量重写原型对象 很多时候，我们为了书写的方便以及直观上的”封装性”，我们往往采用对象字面量直接重写整个原型对象： 1234567891011function Student() &#123;&#125;Student.prototype = &#123; constructor : Student, name : &quot;easy&quot;, age : 20, alertName : function() &#123; alert(this.name); &#125;&#125; 要特别注意，我们这里相当于用对象字面量重新创建了一个Object对象，然后使Student的prototype指针指向该对象。该对象在创建的过程中，自动获得了新的constructor属性，该属性指向Object的构造函数。因此，我们在以上代码中，增加了constructor : Student使其重新指回Student构造函数。 原型模型创建对象的局限性原型模型在对象实例共享数据方面给我们带来了很大的便利，但通常情况下不同的实例会希望拥有属于自己单独的属性。我们将构造函数模型和原型模型结合使用即可兼得数据共享和”不共享”。 构造与原型混合模式创建对象我们结合原型模式在共享方法属性以及构造函数模式在实例方法属性方面的优势，使用以下的方法创建对象： 123456789101112131415161718192021//我们希望每个stu拥有属于自己的name和age属性function Student(name, age) &#123; this.name = name; this.age = age;&#125;//所有的stu应该共享一个alertName()方法Student.prototype = &#123; constructor : Student, alertName : function() &#123; alert(this.name); &#125;&#125;var stu1 = new Student(&quot;Jim&quot;, 20);var stu2 = new Student(&quot;Tom&quot;, 21);stu1.alertName(); //Jim 实例属性stu2.alertName(); //Tom 实例属性alert(stu1.alertName == stu2.alertName); //true 共享函数 以上，在构造函数中定义实例属性，在原型中定义共享属性的模式，是目前使用最广泛的方式。通常情况下，我们都会默认使用这种方式来定义引用类型变量。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[music | 我的音乐 | 我的视频]]></title>
      <url>%2F2017%2F03%2F31%2Fmusic%2F</url>
      <content type="text"><![CDATA[Leego的音乐夹单个歌曲 这是用外链的形式 这是用插件aplayer new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: true, showlrc: 0, music: { title: "平凡之路", author: "朴树", url: "https://ogd99kckh.qnssl.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3", pic: "https://ogd99kckh.qnssl.com/1.jpg", } }); 多个歌曲 var options = {"narrow":false,"autoplay":true,"showlrc":3,"mode":"random","music":[{"title":"平凡之路","author":"朴树","url":"http://og9ocpmwk.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3","pic":"https://ogd99kckh.qnssl.com/1.jpg","lrc":"http://og9ocpmwk.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.txt"},{"title":"野子","author":"苏运莹","url":"http://og9ocpmwk.bkt.clouddn.com/01%20%E9%87%8E%E5%AD%90.m4a","pic":"http://og9ocpmwk.bkt.clouddn.com/%E9%87%8E%E5%AD%90.jpg","lrc":"https://ogd99kckh.qnssl.com/%E9%87%8E%E5%AD%90.txt"}]}; options.element = document.getElementById("aplayer1"); new APlayer(options); 这是用插件dplayer 视频var dplayer0 = new DPlayer({"element":document.getElementById("dplayer0"),"autoplay":false,"theme":"#FADFA3","loop":true,"video":{"url":"http://devtest.qiniudn.com/若能绽放光芒.mp4","pic":"http://devtest.qiniudn.com/若能绽放光芒.png"},"danmaku":{"api":"http://dplayer.donot.help/dplayerpy","id":"2622668","addition":["https://dplayer.daoapp.io/bilibili?aid=4157142"]}});]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工作中常用的单词]]></title>
      <url>%2F2017%2F03%2F31%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%95%E8%AF%8D%2F</url>
      <content type="text"><![CDATA[记得刚开始实习的时候，对公司的业务一点也不熟悉，然后看见各式各样的单词，当时就罗列了一些，方便以后查阅记忆，果然还是很蠢… Leego的工作单词笔记Aattachment：附件attach point：附着点areas : 区域axis ： 轴arrow：箭头available：可用的，可供 Bbars : 水平条banner 页面上的一个横条 Cconfig：配置contactor:开关contract:合同container：容器calendar：日历cache：缓存customer：顾客confirm：批准、证实claro : 味淡而色薄chart：图标chain：链接，链子combine：组合calculate：计算 Ddelegate：委托，代理declare：继承dialog：对话框dealer：经销商detail：细节daily record：每日纪事报default：默认decoration 装饰dotted 点线directory：目录devices：设备 Eextend：拓展edit：打印、编辑effects：效果expression：表达 Ffield：场地format：版式、格局features ：特征 Ggreet:问候grid：栅格gap：缝隙 HIinherit：继承initial：最初的 Jjustify 两端对齐 Kkernel：核心 Llayout：布局 MNOoperator：操作员 observables：可观察的 Ppublic：发布portal：门户plugins: 插件profile：轮廓、外表plot ：制图、绘图、地基、块parser：解析器purple 紫色params：参数 Qquote：报价单 Rrouter：路由器register：登记resource：资源reply：回答regedit：打开注册表registry：注册表received：收到 Ssubscribe:订阅stacked：叠加、堆、series：系列sharp：高级的，专业的，尖锐的slide：滑入square 方块silver 银色specify ：指定，描述，详细特征scan ：扫描scale：缩放比例sniff：闻，嗅statements：陈述，声明 Ttopic:主题track：轨道、路径、追踪themes:主题template：模块tension：拉力，张力tutorial：辅导资料toggle：切换 UVvisible：可见的validate：验证方法vertical 竖直的visited 访问过的 Wwidgets:小部件wetland：湿地wipe：擦除 XYZ]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown]]></title>
      <url>%2F2017%2F03%2F29%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： [x] 已完成事项 [ ] 待办事项1 [ ] 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。 脚注示例：]]></content>
    </entry>

    
  
  
</search>
