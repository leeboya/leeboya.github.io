<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[函数节流与函数防抖]]></title>
      <url>%2F2017%2F04%2F05%2F%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%E4%B8%8E%E5%87%BD%E6%95%B0%E9%98%B2%E6%8A%96%2F</url>
      <content type="text"><![CDATA[我们知道目前的一种说法是当 1 秒内连续播放 24 张以上的图片时，在人眼的视觉中就会形成一个连贯的动画，所以在电影的播放（以前是，现在不知道）中基本是以每秒 24 张的速度播放的，为什么不 100 张或更多是因为 24 张就可以满足人类视觉需求的时候，100 张就会显得很浪费资源。再举个栗子，假设电梯一次只能载一人的话，10 个人要上楼的话电梯就得走 10 次，是一种浪费资源的行为；而实际生活正显然不是这样的，当电梯里有人准备上楼的时候如果外面又有人按电梯的话，电梯会再次打开直到满载位置，从电梯的角度来说，这时一种节约资源的行为（相对于一次只能载一个人）。 什么是函数节流与函数防抖 函数节流: 指定时间间隔内只会执行一次任务。 函数防抖: 任务频繁触发的情况下，只有任务触发的间隔超过指定间隔的时候，任务才会执行。 函数节流(throttle)这里以判断页面是否滚动到底部为例，普通的做法就是监听 window 对象的 scroll 事件，然后再函数体中写入判断是否滚动到底部的逻辑： 12345678910$(window).on('scroll', function () &#123; // 判断是否滚动到底部的逻辑 let pageHeight = $('body').height(), scrollTop = $(window).scrollTop(), winHeight = $(window).height(), thresold = pageHeight - scrollTop - winHeight; if (thresold &gt; -100 &amp;&amp; thresold &lt;= 20) &#123; console.log('end'); &#125;&#125;); 这样做的一个缺点就是比较消耗性能，因为当在滚动的时候，浏览器会无时不刻地在计算判断是否滚动到底部的逻辑，而在实际的场景中是不需要这么做的，在实际场景中可能是这样的：在滚动过程中，每隔一段时间在去计算这个判断逻辑。而函数节流所做的工作就是每隔一段时间去执行一次原本需要无时不刻地在执行的函数，所以在滚动事件中引入函数的节流是一个非常好的实践： 12345678910(window).on('scroll', throttle(function () &#123; // 判断是否滚动到底部的逻辑 let pageHeight = $('body').height(), scrollTop = $(window).scrollTop(), winHeight = $(window).height(), thresold = pageHeight - scrollTop - winHeight; if (thresold &gt; -100 &amp;&amp; thresold &lt;= 20) &#123; console.log('end'); &#125;&#125;)); 加上函数节流之后，当页面再滚动的时候，每隔 300ms 才会去执行一次判断逻辑。 简单来说，函数的节流就是通过闭包保存一个标记（canRun = true），在函数的开头判断这个标记是否为 true，如果为 true 的话就继续执行函数，否则则 return 掉，判断完标记后立即把这个标记设为 false，然后把外部传入的函数的执行包在一个 setTimeout 中，最后在 setTimeout 执行完毕后再把标记设置为 true（这里很关键），表示可以执行下一次的循环了。当 setTimeout 还未执行的时候，canRun 这个标记始终为 false，在开头的判断中被 return 掉。 123456789101112//声明函数节流function throttle(fn, interval = 300) &#123; let canRun = true; return function () &#123; if (!canRun) return; canRun = false; setTimeout(() =&gt; &#123; fn.apply(this, arguments); canRun = true; &#125;, interval); &#125;;&#125; 函数防抖(debounce)这里以用户注册时验证用户名是否被占用为例，如今很多网站为了提高用户体验，不会再输入框失去焦点的时候再去判断用户名是否被占用，而是在输入的时候就在判断这个用户名是否已被注册： 12345678910111213141516171819$('input.user-name').on('input', function () &#123; $.ajax(&#123; url: `https://just.com/check`, method: 'post', data: &#123; username: $(this).val(), &#125;, success(data) &#123; if (data.isRegistered) &#123; $('.tips').text('该用户名已被注册！'); &#125; else &#123; $('.tips').text('恭喜！该用户名还未被注册！'); &#125; &#125;, error(error) &#123; console.log(error); &#125;, &#125;);&#125;); 很明显，这样的做法不好的是当用户输入第一个字符的时候，就开始请求判断了，不仅对服务器的压力增大了，对用户体验也未必比原来的好。而理想的做法应该是这样的，当用户输入第一个字符后的一段时间内如果还有字符输入的话，那就暂时不去请求判断用户名是否被占用。在这里引入函数防抖就能很好地解决这个问题： 12345678910111213141516171819$('input.user-name').on('input', debounce(function () &#123; $.ajax(&#123; url: `https://just.com/check`, method: 'post', data: &#123; username: $(this).val(), &#125;, success(data) &#123; if (data.isRegistered) &#123; $('.tips').text('该用户名已被注册！'); &#125; else &#123; $('.tips').text('恭喜！该用户名还未被注册！'); &#125; &#125;, error(error) &#123; console.log(error); &#125;, &#125;);&#125;)); 其实函数防抖的原理也非常地简单，通过闭包保存一个标记来保存 setTimeout 返回的值，每当用户输入的时候把前一个 setTimeout clear 掉，然后又创建一个新的 setTimeout，这样就能保证输入字符后的 interval 间隔内如果还有字符输入的话，就不会执行 fn 函数了。 12345678910//声明函数防抖function debounce(fn, interval = 300) &#123; let timeout = null; return function () &#123; clearTimeout(timeout); timeout = setTimeout(() =&gt; &#123; fn.apply(this, arguments); &#125;, interval); &#125;;&#125; 总结其实函数节流与函数防抖的原理非常简单，巧妙地使用 setTimeout 来存放待执行的函数，这样可以很方便的利用 clearTimeout 在合适的时机来清除待执行的函数。 使用函数节流与函数防抖的目的，在开头的栗子中应该也能看得出来，就是为了节约计算机资源。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[用CSS实现的一些loading动画效果]]></title>
      <url>%2F2017%2F04%2F05%2F%E7%94%A8CSS%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%B8%80%E4%BA%9Bloading%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%2F</url>
      <content type="text"><![CDATA[css实现的一些加载动画Loding动画一Loding动画一 关键代码：html1234567&lt;div class="spinner"&gt; &lt;div class="rect1"&gt;&lt;/div&gt; &lt;div class="rect2"&gt;&lt;/div&gt; &lt;div class="rect3"&gt;&lt;/div&gt; &lt;div class="rect4"&gt;&lt;/div&gt; &lt;div class="rect5"&gt;&lt;/div&gt;&lt;/div&gt; CSS 12345678910111213141516171819202122232425262728293031323334353637383940.spinner &#123; width: 50px; height: 60px; text-align: center; font-size: 10px;&#125;.spinner &gt; div &#123; height: 100%; width: 6px; background-color: #67CF22; display: inline-block; animation: stretchdelay 1.2s infinite ease-in-out;&#125;.spinner .rect2 &#123; animation-delay: -1.1s;&#125;.spinner .rect3 &#123; animation-delay: -1.0s;&#125;.spinner .rect4 &#123; animation-delay: -0.9s;&#125;.spinner .rect5 &#123; animation-delay: -0.8s;&#125;@keyframes stretchdelay &#123; 0%, 40%, 100% &#123; transform: scaleY(0.4); &#125; 20% &#123; transform: scaleY(1.0); &#125;&#125; Loding动画二Loding动画二 关键代码：html1&lt;div class="spinner"&gt;&lt;/div&gt; CSS 1234567891011121314151617.spinner &#123; width: 60px; height: 60px; background-color: #67CF22; margin: 100px auto; animation: rotateplane 1.2s infinite ease-in-out;&#125;@keyframes rotateplane &#123; 0% &#123; transform: perspective(120px) rotateX(0deg) rotateY(0deg); &#125; 50% &#123; transform: perspective(120px) rotateX(-180.1deg) rotateY(0deg); &#125; 100% &#123; transform: perspective(120px) rotateX(-180deg) rotateY(-179.9deg); &#125;&#125; Loding动画三Loding动画三 关键代码：html1234&lt;div class="spinner"&gt; &lt;div class="double-bounce1"&gt;&lt;/div&gt; &lt;div class="double-bounce2"&gt;&lt;/div&gt;&lt;/div&gt; CSS 123456789101112131415161718192021222324252627282930313233.spinner &#123; width: 60px; height: 60px; position: relative; margin: 100px auto;&#125;.double-bounce1, .double-bounce2 &#123; width: 100%; height: 100%; border-radius: 50%; background-color: #67CF22; opacity: 0.6; position: absolute; top: 0; left: 0; animation: bounce 2.0s infinite ease-in-out;&#125;.double-bounce2 &#123; animation-delay: -1.0s;&#125;@keyframes bounce &#123; 0%, 100% &#123; transform: scale(0.0); &#125; 50% &#123; transform: scale(1.0); &#125;&#125; Loding动画四Loding动画四 关键代码：html1234&lt;div class="spinner"&gt; &lt;div class="cube1"&gt;&lt;/div&gt; &lt;div class="cube2"&gt;&lt;/div&gt;&lt;/div&gt; CSS 123456789101112131415161718192021222324252627282930313233343536.spinner &#123; margin: 100px auto; width: 32px; height: 32px; position: relative;&#125;.cube1, .cube2 &#123; background-color: #67CF22; width: 30px; height: 30px; position: absolute; top: 0; left: 0; animation: cubemove 1.8s infinite ease-in-out;&#125;.cube2 &#123; animation-delay: -0.9s;&#125;@keyframes cubemove &#123; 25% &#123; transform: translateX(42px) rotate(-90deg) scale(0.5); &#125; 50% &#123; transform: translateX(42px) translateY(42px) rotate(-179deg); &#125; 50.1% &#123; transform: translateX(42px) translateY(42px) rotate(-180deg); &#125; 75% &#123; transform: translateX(0px) translateY(42px) rotate(-270deg) scale(0.5); &#125; 100% &#123; transform: rotate(-360deg); &#125;&#125; Loding动画五Loding动画五 关键代码：html1234&lt;div class="spinner"&gt; &lt;div class="dot1"&gt;&lt;/div&gt; &lt;div class="dot2"&gt;&lt;/div&gt;&lt;/div&gt; CSS 123456789101112131415161718192021222324252627282930313233343536.spinner &#123; margin: 100px auto; width: 90px; height: 90px; position: relative; text-align: center; animation: rotate 2.0s infinite linear;&#125;.dot1, .dot2 &#123; width: 60%; height: 60%; display: inline-block; position: absolute; top: 0; background-color: #67CF22; border-radius: 100%; animation: bounce 2.0s infinite ease-in-out;&#125;.dot2 &#123; top: auto; bottom: 0px; animation-delay: -1.0s;&#125;@keyframes rotate &#123; 100% &#123; transform: rotate(360deg);&#125;&#125;@keyframes bounce &#123; 0%, 100% &#123; transform: scale(0.0); &#125; 50% &#123; transform: scale(1.0); &#125;&#125; Loding动画六Loding动画六 关键代码：html12345&lt;div class="spinner"&gt; &lt;div class="bounce1"&gt;&lt;/div&gt; &lt;div class="bounce2"&gt;&lt;/div&gt; &lt;div class="bounce3"&gt;&lt;/div&gt;&lt;/div&gt; CSS 1234567891011121314151617181920212223242526272829303132333435363738394041424344.spinner &#123; margin: 100px auto 0; width: 150px; text-align: center;&#125;.spinner &gt; div &#123; width: 30px; height: 30px; background-color: #67CF22; border-radius: 100%; display: inline-block; -webkit-animation: bouncedelay 1.4s infinite ease-in-out; animation: bouncedelay 1.4s infinite ease-in-out; /* Prevent first frame from flickering when animation starts */ -webkit-animation-fill-mode: both; animation-fill-mode: both;&#125;.spinner .bounce1 &#123; -webkit-animation-delay: -0.32s; animation-delay: -0.32s;&#125;.spinner .bounce2 &#123; -webkit-animation-delay: -0.16s; animation-delay: -0.16s;&#125;@-webkit-keyframes bouncedelay &#123; 0%, 80%, 100% &#123; -webkit-transform: scale(0.0) &#125; 40% &#123; -webkit-transform: scale(1.0) &#125;&#125;@keyframes bouncedelay &#123; 0%, 80%, 100% &#123; transform: scale(0.0); -webkit-transform: scale(0.0); &#125; 40% &#123; transform: scale(1.0); -webkit-transform: scale(1.0); &#125;&#125; Loding动画七Loding动画七 关键代码：html1&lt;div class="spinner"&gt;&lt;/div&gt; CSS 123456789101112131415161718.spinner &#123; width: 40px; height: 40px; margin: 100px auto; background-color: #67CF22; border-radius: 100%; animation: scaleout 1.0s infinite ease-in-out;&#125;@keyframes scaleout &#123; 0% &#123; transform: scale(0.0); -webkit-transform: scale(0.0); &#125; 100% &#123; transform: scale(1.0); opacity: 0; &#125;&#125; Loding动画八Loding动画八 关键代码：html1234567891011121314151617181920&lt;div class="spinner"&gt; &lt;div class="spinner-container container1"&gt; &lt;div class="circle1"&gt;&lt;/div&gt; &lt;div class="circle2"&gt;&lt;/div&gt; &lt;div class="circle3"&gt;&lt;/div&gt; &lt;div class="circle4"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="spinner-container container2"&gt; &lt;div class="circle1"&gt;&lt;/div&gt; &lt;div class="circle2"&gt;&lt;/div&gt; &lt;div class="circle3"&gt;&lt;/div&gt; &lt;div class="circle4"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div class="spinner-container container3"&gt; &lt;div class="circle1"&gt;&lt;/div&gt; &lt;div class="circle2"&gt;&lt;/div&gt; &lt;div class="circle3"&gt;&lt;/div&gt; &lt;div class="circle4"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; CSS 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687.spinner &#123; margin: 100px auto; width: 20px; height: 20px; position: relative;&#125;.container1 &gt; div, .container2 &gt; div, .container3 &gt; div &#123; width: 6px; height: 6px; background-color: #67CF22; border-radius: 100%; position: absolute; animation: bouncedelay 1.2s infinite ease-in-out; animation-fill-mode: both;&#125;.spinner .spinner-container &#123; position: absolute; width: 100%; height: 100%;&#125;.container2 &#123; transform: rotateZ(45deg);&#125;.container3 &#123; transform: rotateZ(90deg);&#125;.circle1 &#123; top: 0; left: 0; &#125;.circle2 &#123; top: 0; right: 0; &#125;.circle3 &#123; right: 0; bottom: 0; &#125;.circle4 &#123; left: 0; bottom: 0; &#125;.container2 .circle1 &#123; animation-delay: -1.1s;&#125;.container3 .circle1 &#123; animation-delay: -1.0s;&#125;.container1 .circle2 &#123; animation-delay: -0.9s;&#125;.container2 .circle2 &#123; animation-delay: -0.8s;&#125;.container3 .circle2 &#123; animation-delay: -0.7s;&#125;.container1 .circle3 &#123; animation-delay: -0.6s;&#125;.container2 .circle3 &#123; animation-delay: -0.5s;&#125;.container3 .circle3 &#123; animation-delay: -0.4s;&#125;.container1 .circle4 &#123; animation-delay: -0.3s;&#125;.container2 .circle4 &#123; animation-delay: -0.2s;&#125;.container3 .circle4 &#123; animation-delay: -0.1s;&#125;@keyframes bouncedelay &#123; 0%, 80%, 100% &#123; transform: scale(0.0); &#125; 40% &#123; transform: scale(1.0); &#125;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[自己项目中常用的CSS动画]]></title>
      <url>%2F2017%2F04%2F05%2F%E8%87%AA%E5%B7%B1%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84CSS%E5%8A%A8%E7%94%BB%2F</url>
      <content type="text"><![CDATA[下面是一些常用的CSS动画示例，点击示例链接可在线编辑、查看效果(RunJS)，考虑兼容性，请自行加上浏览器内核前缀，让我们直接进入正题吧：CSS3呼吸灯效果呼吸灯效果示例 关键代码： 下面的breath_light_before，breath_light_after是给对应的伪类的呼吸灯class 12345678910111213.breath_light, .breath_light_before::before, .breath_light_after::after&#123; /* IE10、Firefox and Opera，IE9以及更早的版本不支持 */ animation-name: breath; /* 动画名称 */ animation-duration: 3s; /* 动画时长3秒 */ animation-timing-function: ease-in-out; /* 动画速度曲线：以低速开始和结束 */ animation-iteration-count: infinite; /* 播放次数：无限 */&#125;@keyframes breath &#123; from &#123; opacity: 0.1; &#125; /* 动画开始时的不透明度 */ 50% &#123; opacity: 1; &#125; /* 动画50% 时的不透明度 */ to &#123; opacity: 0.1; &#125; /* 动画结束时的不透明度 */&#125; CSS3旋转效果旋转效果示例 关键代码： 123456789101112131415161718192021.btn-rotate &#123; position: absolute; transform-origin: center; animation-name: rotate; animation-duration: 3s; animation-timing-function: linear; animation-delay: 0s; animation-iteration-count: infinite; // n | infinite animation-direction: direction; animation-fill-mode: fillmode; &#125;@keyframes rotate &#123; from&#123; transform: rotate(0deg); &#125; to&#123; transform: rotate(720deg); &#125;&#125; stylus 中的函数模式1234567891011121314151617181920212223242526//定义旋转方法transformRotate(origin=center,name=icon-rotate,duration=5s,timfn=linear,delay=0s,count=1,direction=normal,fillmode=forwards)&#123; transform-origin:origin; animation-name: name; animation-duration: duration; animation-timing-function: timfn; animation-delay: delay; animation-iteration-count: count; // n | infinite animation-direction: direction; animation-fill-mode: fillmode;&#125;//刷新按钮.btn-refresh &#123; &amp;:hover .dijitIcon&#123; transformRotate(center,icon-rotate,3s,linear,0s,infinite);//调用函数并传参 &#125;&#125;@keyframes icon-rotate &#123; from&#123; transform: rotate(0deg); &#125; to&#123; transform: rotate(720deg); &#125;&#125; CSS3鼠标移入显示线条鼠标移入看线条哦 关键代码：12345678910111213141516171819202122.scale-line&#123; position: relative;&#125;.scale-line::after&#123; content: ""; width: 100%; height: 1px; background-color: #000; position: absolute; left: 0; bottom: 0; transform: scaleX(0); transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s;&#125;.scale-line:hover::after&#123; visibility: visible; transform: scaleX(1);&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS中的继承]]></title>
      <url>%2F2017%2F04%2F05%2FJS%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
      <content type="text"><![CDATA[众所周知，在 ES6 之前没有类的概念，所以不能像 Java 中一个 extends 关键字就搞定了继承关系，需要一些 tricks 来实现，下面就介绍一些比较常用的方法,意在快速 get 到 JS 中继承的几种主要方式。 （一）原型链继承：12345678910111213141516171819function Parent(name) &#123; this.name = name;&#125;Parent.prototype.sayName = function() &#123; console.log('parent name:', this.name);&#125;function Child(name) &#123; this.name = name;&#125;Child.prototype = new Parent('father');Child.prototype.constructor = Child;Child.prototype.sayName = function() &#123; console.log('child name:', this.name);&#125;var child = new Child('son');child.sayName(); // child name: son 只要是原型链中出现过的原型，都可以说是该原型链派生的实例的原型。 这种方法存在两个缺点： 子类型无法给超类型传递参数。在面向对象的继承中，我们总希望通过 var child = new Child(‘son’, ‘father’); 让子类去调用父类的构造器来完成继承。而不是通过像这样 new Parent(‘father’) 去调用父类。 Child.prototype.sayName 必须写在 Child.prototype = new Parent(‘father’); 之后，不然就会被覆盖掉。 （二）类式继承123456789101112131415161718192021function Parent(name) &#123; this.name = name;&#125;Parent.prototype.sayName = function() &#123; console.log('parent name:', this.name);&#125;Parent.prototype.doSomthing = function() &#123; console.log('parent do something!');&#125;function Child(name, parentName) &#123; Parent.call(this, parentName); this.name = name;&#125;Child.prototype.sayName = function() &#123; console.log('child name:', this.name);&#125;var child = new Child('son');child.sayName(); // child name: sonchild.doSomthing(); // TypeError: child.doSomthing is not a function 相当于 Parent 这个函数在 Child 函数中执行了一遍，并且将所有与 this 绑定的变量都切换到了 Child 上，这样就克服了第一种方式带来的问题。 缺点：没有原型，每次创建一个 Child 实例对象时候都需要执行一遍 Parent 函数，无法复用一些公用函数。 (三) 组合式继承：前两种方式的结合12345678910111213141516171819202122232425function Parent(name) &#123; this.name = name;&#125;Parent.prototype.sayName = function() &#123; console.log('parent name:', this.name);&#125;Parent.prototype.doSomething = function() &#123; console.log('parent do something!');&#125;function Child(name, parentName) &#123; Parent.call(this, parentName); this.name = name;&#125;Child.prototype.sayName = function() &#123; console.log('child name:', this.name);&#125;Child.prototype = new Parent(); Child.prototype.construtor = Child;var child = new Child('son');child.sayName(); // child name: sonchild.doSomething(); // parent do something! 组合式继承是比较常用的一种继承方法，其背后的思路是使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。 这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 组合式继承是 JS 最常用的继承模式，但组合继承使用过程中会被调用两次：一次是创建子类型的时候，另一次是在子类型构造函数的内部。 123456789101112131415161718192021222324function Parent(name) &#123; this.name = name;&#125;Parent.prototype.sayName = function() &#123; console.log('parent name:', this.name);&#125;Parent.prototype.doSomething = function() &#123; console.log('parent do something!');&#125;function Child(name, parentName) &#123; Parent.call(this, parentName); // 第二次调用 this.name = name;&#125;Child.prototype.sayName = function() &#123; console.log('child name:', this.name);&#125;Child.prototype = new Parent(); // 第一次调用Child.prototype.construtor = Child;var child = new Child('son');child.sayName(); child.doSomething(); 显然从上述的代码中可以看出，第一次调用构造函数显然是没有必要的，因为第一次调用构造函数时候不需要函数内部的那些实例属性，这么写只是想获得其原型上的方法罢了，所以这时候你可能会这样写： 1Child.prototype = Parent.prototype; 这样写显然是不对的： 首先，你这样写的话相当于是子类和父类都指向同一个对象，这时候如果你添加了新的方法给 Child 但实际上 Parent 并不需要，相当于强行给 Parent 添加了一个未知的方法。 其次，仔细想想，这样体现不出继承的多态性，比如此时子类想要重写父类的 getName 的方法，那么父类的方法也就会随之修改，这显然违背了多态性。 也就是说我们第一次调用构造函数的时候，其实是不管构造函数里面的内容，所以我们何不 new 一个空函数，将其 prototype 指向 Parent.prototype，代码如下： (四) 寄生组合式继承：12345678910111213141516171819202122232425262728293031function Parent(name) &#123; this.name = name;&#125;Parent.prototype.sayName = function() &#123; console.log('parent name:', this.name);&#125;function Child(name, parentName) &#123; Parent.call(this, parentName); this.name = name; &#125;function create(proto) &#123; function F()&#123;&#125; F.prototype = proto; F.prototype.construtor = F; return new F();&#125;Child.prototype = create(Parent.prototype);Child.prototype.sayName = function() &#123; console.log('child name:', this.name);&#125;Child.prototype.construtor = Child;var parent = new Parent('father');parent.sayName(); // parent name: fathervar child = new Child('son', 'father');child.sayName(); // child name: son 这就是所谓的 寄生组合式继承方式，跟组合式继承的区别在于，他不需要在一次实例中调用两次父类的构造函数，假如说父类的构造器代码很多，还需要调用两次的话对系统肯定会有影响，寄生组合式继承的思想在于：用一个 F 空的构造函数去取代执行了 Parent 这个构造函数。 在上面的代码中，我们手动创建了一个 create 函数，但是其实是存在于 Object 对象中，不需要我们手动去创建，所以上面的代码可以改为： 12345678910111213141516171819202122232425262728function Parent(name) &#123; this.name = name;&#125;Parent.prototype.sayName = function() &#123; console.log('parent name:', this.name);&#125;function Child(name, parentName) &#123; Parent.call(this, parentName); this.name = name; &#125;function inheritPrototype(Parent, Child) &#123; Child.prototype = Object.create(Parent.prototype); //修改 Child.prototype.construtor = Child;&#125;inheritPrototype(Parent, Child);Child.prototype.sayName = function() &#123; console.log('child name:', this.name);&#125;var parent = new Parent('father');parent.sayName(); // parent name: fathervar child = new Child('son', 'father');child.sayName(); // child name: son (五) ES 6 继承：当然，如果你学习过 ES 6，那么写继承关系就会特别简单，上述的代码可改为： 12345678910111213141516171819202122232425262728class Parent &#123; constructor(name) &#123; this.name = name; &#125; doSomething() &#123; console.log('parent do something!'); &#125; sayName() &#123; console.log('parent name:', this.name); &#125;&#125;class Child extends Parent &#123; constructor(name, parentName) &#123; super(parentName); this.name = name; &#125; sayName() &#123; console.log('child name:', this.name); &#125;&#125;const child = new Child('son', 'father');child.sayName(); // child name: sonchild.doSomething(); // parent do something!const parent = new Parent('father');parent.sayName(); // parent name: father]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Where Is the Love]]></title>
      <url>%2F2017%2F04%2F02%2Fwhere-is-the-love%2F</url>
      <content type="text"><![CDATA[Josh Vietti简介josh vietti是一位乐观，热情极具个人魅力的年轻音乐家，他出生于美国加州，4岁就开始学习小提琴，并在2006年由于对音乐的狂热，josh开创了自己的事业。最初他在美国的Santa Monica（圣塔莫尼卡）第三St. Promenade大道做街头表演，并且由此卖出了15000张CD唱片。后来被著名的歌手Brian Kennedy (Rihanna, Chris Brown, Jennifer Hudson) 和 Kashif (Whitney Houston &amp; Kenny G)发现，并邀请他在他们的现场音乐会上演出，后来在工作室中为他录制音乐。 有些事情，现在不去做，以后很有可能永远也做不了。不是没时间，就是因为有时间，你才会一拖再拖，放心让它们搁在那里，任凭风吹雨打，铺上厚厚的灰尘。而你终将遗忘曾经想要做的事、想要说的话、想要抓住的人。 new APlayer({ element: document.getElementById("aplayer2"), narrow: false, autoplay: true, showlrc: 0, music: { title: "Where Is the Love", author: "Josh Vietti", url: "http://onknvpesb.bkt.clouddn.com/Josh%20Vietti%20-%20Where%20Is%20the%20Love.mp3", pic: "http://onknvpesb.bkt.clouddn.com/JoshVietti.jpg", } }); 喜欢这首曲子的朋友可以点击下方分享哦，也可以在网易云音乐关注我（页面右边侧边栏”站点概览”有连接:-D），一起互荐好听的音乐吧！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JavaScript构造函数及原型对象]]></title>
      <url>%2F2017%2F04%2F01%2FJavaScript%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%8F%8A%E5%8E%9F%E5%9E%8B%E5%AF%B9%E8%B1%A1%2F</url>
      <content type="text"><![CDATA[JavaScript构造函数及原型对象JavaScript中没有类的概念，所以其在对象创建方面与面向对象语音有所不同。 JS中对象可以定义为”无序属性的集合”。其属性可以包含基本值，对象以及函数。对象实质上就是一组没有特定顺序的值，对象中每个属性、方法都有一个名字，每个名字都映射到了一个值，因此我们可以将对象想象称为一个散列表。 JS是一种基于对象的语言，对象的概念在JS体系中十分的重要，因此有必要清楚地了解一下JS中对象创建的常用方法及各自的局限性。 使用Object或对象字面量创建对象在说工厂模式创建对象之前，我们不妨回顾一下JS中最基本的创建对象的方法，比如说我想创建一个student对象怎么办？最简单地，new一个Object： 123var student = new Object();student.name = "easy";student.age = "20"; 这样，一个student对象就创建完毕，拥有2个属性name以及age，分别赋值为”easy”和20。 如果你嫌这种方法有一种封装性不良的感觉，我们也可以使用对象字面量的方式来创建student对象： 1234var sutdent = &#123; name : "easy", age : 20&#125;; 这样看起来似乎就完美了。但是马上我们就会发现一个十分尖锐的问题：当我们要创建同类的student1，student2，…，studentn时，我们不得不将以上的代码重复n次。 12345678910111213141516 var sutdent1 = &#123; name : "easy1", age : 20 &#125;; var sutdent2 = &#123; name : "easy2", age : 20 &#125;;//... var sutdentn = &#123; name : "easyn", age : 20 &#125;; 能不能像工厂车间那样，有一个车床就不断生产出对象呢？我们看”工厂模式”。 工厂模式创建对象JS中没有类的概念，那么我们不妨就使用一种函数将以上对象创建过程封装起来以便于重复调用，同时可以给出特定接口来初始化对象： 1234567891011function createStudent(name, age) &#123; var obj = new Object(); obj.name = name; obj.age = age; return obj;&#125;var student1 = createStudent("easy1", 20);var student2 = createStudent("easy2", 20);//...var studentn = createStudent("easyn", 20); 这样一来我们就可以通过createStudent函数源源不断地”生产”对象了。看起来已经高枕无忧了，但贪婪的人类总有不满足于现状的天性：我们不仅希望”产品”的生产可以像工厂车间一般源源不断，我们还想知道生产的产品究竟是哪一种类型的。 比如说，我们同时又定义了”生产”水果对象的createFruit()函数： 123456789function createFruit(name, color) &#123; var obj = new Object(); obj.name = name; obj.color = color; return obj;&#125;var v1 = createStudent("easy1", 20);var v2 = createFruit("apple", "green"); 对于以上代码创建的对象v1、v2，我们用instanceof操作符去检测，他们统统都是Object类型。我们的当然不满足于此，我们希望v1是Student类型的，而v2是Fruit类型的。为了实现这个目标，我们可以用自定义构造函数的方法来创建对象。 构造函数模式创建对象在上面创建Object这样的原生对象的时候，我们就使用过其构造函数： 1var obj = new Object(); 在创建原生数组Array类型对象时也使用过其构造函数： 1var arr = new Array(10); //构造一个初始长度为10的数组对象 在进行自定义构造函数创建对象之前，我们首先了解一下构造函数和普通函数有什么区别。 其一，实际上并不存在创建构造函数的特殊语法，其与普通函数唯一的区别在于调用方法。对于任意函数，使用new操作符调用，那么它就是构造函数；不使用new操作符调用，那么它就是普通函数。 其二，按照惯例，我们约定构造函数名以大写字母开头，普通函数以小写字母开头，这样有利于显性区分二者。例如上面的new Array()，new Object()。 其三，使用new操作符调用构造函数时，会经历(1)创建一个新对象；(2)将构造函数作用域赋给新对象（使this指向该新对象）；(3)执行构造函数代码；(4)返回新对象；4个阶段。 了解了构造函数和普通函数的区别之后，我们使用构造函数将工厂模式的函数重写，并添加一个方法属性： 123456789101112131415161718192021222324252627282930function Student(name, age) &#123; this.name = name; this.age = age; this.alertName = function()&#123; alert(this.name) &#125;;&#125;function Fruit(name, color) &#123; this.name = name; this.color = color; this.alertName = function()&#123; alert(this.name) &#125;;&#125;//这样我们再分别创建Student和Fruit的对象：var v1 = new Student("easy", 20);var v2 = new Fruit("apple", "green");//这时我们再来用instanceof操作符来检测以上对象类型就可以区分出Student以及Fruit了：alert(v1 instanceof Student); //truealert(v2 instanceof Student); //falsealert(v1 instanceof Fruit); //falsealert(v2 instanceof Fruit); //truealert(v1 instanceof Object); //true 任何对象均继承自Objectalert(v2 instanceof Object); //true 任何对象均继承自Object 这样我们就解决了工厂模式无法区分对象类型的尴尬。那么使用构造方法来创建对象是否已经完美了呢？ 我们知道在JS中，函数是对象。那么，当我们实例化不止一个Student对象的时候： 1234var v1 = new Student("easy1", 20);var v2 = new Student("easy2", 20);//...var vn = new Student("easyn", 20); 其中共同的alertName()函数也被实例化了n次，我们可以用以下方法来检测不同的Student对象并不共用alertName()函数： 1alert(v1.alertName == v2.alertName); //flase 这无疑是一种内存的浪费。我们知道，this对象是在运行时基于函数的执行环境进行绑定的。在全局函数中，this对象等同于window；在对象方法中，this指向该对象。在上面的构造函数中： 123this.alertName = function()&#123; alert(this.name) &#125;; 我们在创建对象（执行alertName函数之前）时，就将alertName()函数绑定在了该对象上。我们完全可以在执行该函数的时候再这样做，办法是将对象方法移到构造函数外部： 123456789101112function Student(name, age) &#123; this.name = name; this.age = age; this.alertName = alertName;&#125;function alertName() &#123; alert(this.name);&#125;var stu1 = new Student("easy1", 20);var stu2 = new Student("easy2", 20); 在调用stu1.alert()时，this对象才被绑定到stu1上。 我们通过将alertName()函数定义为全局函数，这样对象中的alertName属性则被设置为指向该全局函数的指针。由此stu1和stu2共享了该全局函数，解决了内存浪费的问题。 但是，通过全局函数的方式解决对象内部共享的问题，终究不像一个好的解决方法。如果这样定义的全局函数多了，我们想要将自定义对象封装的初衷便几乎无法实现了。更好的方案是通过原型对象模式来解决。 原型模式创建对象函数的原型对象在了解如何使用原型模式创建对象之前，有必要先搞清楚什么是原型对象。 我们创建的每一个函数都有一个prototype属性，该属性是一个指针，该指针指向了一个对象。对于我们创建的构造函数，该对象中包含可以由所有实例共享的属性和方法。如下如所示： 在默认情况下，所有原型对象会自动包含一个constructor属性，该属性也是一个指针，指向prototype所在的函数： 对象实例和原型对象的关联在调用构造函数创建新的实例时，该实例的内部会自动包含一个[[Prototype]]指针属性，该指针指便指向构造函数的原型对象。注意，这个指针关联的是实例与构造函数的原型对象而不是实例与构造函数： 使用原型模型创建对象直接在原型对象中添加属性和方法 了解了原型对象之后，我们便可以通过在构造函数原型对象中添加属性和方法来实现对象间数据的共享了。例如： 12345678910111213141516function Student() &#123;&#125;Student.prototype.name = "easy";Student.prototype.age = 20;Student.prototype.alertName = function()&#123; alert(this.name);&#125;;var stu1 = new Student();var stu2 = new Student();stu1.alertName(); //easystu2.alertName(); //easyalert(stu1.alertName == stu2.alertName); //true 二者共享同一函数 以上代码，我们在Student的protptype对象中添加了name、age属性以及alertName()方法。但创建的stu1和stu2中并不包含name、age属性以及alertName()方法，而只包含一个[[prototype]]指针属性。当我们调用stu1.name或stu1.alertName()时，是如何找到对应的属性和方法的呢？ 当我们需要读取对象的某个属性时，都会执行一次搜索。首先在该对象中查找该属性，若找到，返回该属性值；否则，到[[prototype]]指向的原型对象中继续查找。 由此我们也可以看出另外一层意思：如果对象实例中包含和原型对象中同名的属性或方法，则对象实例中的该同名属性或方法会屏蔽原型对象中的同名属性或方法。原因就是“首先在该对象中查找该属性，若找到，返回该属性值；” 拥有同名实例属性或方法的示意图： 上图中，我们在访问stu1.name是会得到”EasySir”： 1alert(stu1.name); //EasySir` 通过对象字面量重写原型对象 很多时候，我们为了书写的方便以及直观上的”封装性”，我们往往采用对象字面量直接重写整个原型对象： 1234567891011function Student() &#123;&#125;Student.prototype = &#123; constructor : Student, name : "easy", age : 20, alertName : function() &#123; alert(this.name); &#125;&#125; 要特别注意，我们这里相当于用对象字面量重新创建了一个Object对象，然后使Student的prototype指针指向该对象。该对象在创建的过程中，自动获得了新的constructor属性，该属性指向Object的构造函数。因此，我们在以上代码中，增加了constructor : Student使其重新指回Student构造函数。 原型模型创建对象的局限性原型模型在对象实例共享数据方面给我们带来了很大的便利，但通常情况下不同的实例会希望拥有属于自己单独的属性。我们将构造函数模型和原型模型结合使用即可兼得数据共享和”不共享”。 构造与原型混合模式创建对象我们结合原型模式在共享方法属性以及构造函数模式在实例方法属性方面的优势，使用以下的方法创建对象： 123456789101112131415161718192021//我们希望每个stu拥有属于自己的name和age属性function Student(name, age) &#123; this.name = name; this.age = age;&#125;//所有的stu应该共享一个alertName()方法Student.prototype = &#123; constructor : Student, alertName : function() &#123; alert(this.name); &#125;&#125;var stu1 = new Student("Jim", 20);var stu2 = new Student("Tom", 21);stu1.alertName(); //Jim 实例属性stu2.alertName(); //Tom 实例属性alert(stu1.alertName == stu2.alertName); //true 共享函数 以上，在构造函数中定义实例属性，在原型中定义共享属性的模式，是目前使用最广泛的方式。通常情况下，我们都会默认使用这种方式来定义引用类型变量。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[music | 我的音乐 | 我的视频]]></title>
      <url>%2F2017%2F03%2F31%2Fmusic%2F</url>
      <content type="text"><![CDATA[Leego的音乐夹单个歌曲 这是用外链的形式 这是用插件aplayer new APlayer({ element: document.getElementById("aplayer0"), narrow: false, autoplay: true, showlrc: 0, music: { title: "平凡之路", author: "朴树", url: "https://ogd99kckh.qnssl.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3", pic: "https://ogd99kckh.qnssl.com/1.jpg", } }); 多个歌曲 var options = {"narrow":false,"autoplay":true,"showlrc":3,"mode":"random","music":[{"title":"平凡之路","author":"朴树","url":"http://og9ocpmwk.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.mp3","pic":"https://ogd99kckh.qnssl.com/1.jpg","lrc":"http://og9ocpmwk.bkt.clouddn.com/%E5%B9%B3%E5%87%A1%E4%B9%8B%E8%B7%AF.txt"},{"title":"野子","author":"苏运莹","url":"http://og9ocpmwk.bkt.clouddn.com/01%20%E9%87%8E%E5%AD%90.m4a","pic":"http://og9ocpmwk.bkt.clouddn.com/%E9%87%8E%E5%AD%90.jpg","lrc":"https://ogd99kckh.qnssl.com/%E9%87%8E%E5%AD%90.txt"}]}; options.element = document.getElementById("aplayer1"); new APlayer(options); 这是用插件dplayer 视频var dplayer0 = new DPlayer({"element":document.getElementById("dplayer0"),"autoplay":false,"theme":"#FADFA3","loop":true,"video":{"url":"http://devtest.qiniudn.com/若能绽放光芒.mp4","pic":"http://devtest.qiniudn.com/若能绽放光芒.png"},"danmaku":{"api":"http://dplayer.donot.help/dplayerpy","id":"2622668","addition":["https://dplayer.daoapp.io/bilibili?aid=4157142"]}});]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工作中常用的单词]]></title>
      <url>%2F2017%2F03%2F31%2F%E5%B7%A5%E4%BD%9C%E4%B8%AD%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%95%E8%AF%8D%2F</url>
      <content type="text"><![CDATA[记得刚开始实习的时候，对公司的业务一点也不熟悉，然后看见各式各样的单词，当时就罗列了一些，方便以后查阅记忆，果然还是很蠢… Leego的工作单词笔记Aattachment：附件attach point：附着点areas : 区域axis ： 轴arrow：箭头available：可用的，可供 Bbars : 水平条banner 页面上的一个横条 Cconfig：配置contactor:开关contract:合同container：容器calendar：日历cache：缓存customer：顾客confirm：批准、证实claro : 味淡而色薄chart：图标chain：链接，链子combine：组合calculate：计算 Ddelegate：委托，代理declare：继承dialog：对话框dealer：经销商detail：细节daily record：每日纪事报default：默认decoration 装饰dotted 点线directory：目录devices：设备 Eextend：拓展edit：打印、编辑effects：效果expression：表达 Ffield：场地format：版式、格局features ：特征 Ggreet:问候grid：栅格gap：缝隙 HIinherit：继承initial：最初的 Jjustify 两端对齐 Kkernel：核心 Llayout：布局 MNOoperator：操作员 observables：可观察的 Ppublic：发布portal：门户plugins: 插件profile：轮廓、外表plot ：制图、绘图、地基、块parser：解析器purple 紫色params：参数 Qquote：报价单 Rrouter：路由器register：登记resource：资源reply：回答regedit：打开注册表registry：注册表received：收到 Ssubscribe:订阅stacked：叠加、堆、series：系列sharp：高级的，专业的，尖锐的slide：滑入square 方块silver 银色specify ：指定，描述，详细特征scan ：扫描scale：缩放比例sniff：闻，嗅statements：陈述，声明 Ttopic:主题track：轨道、路径、追踪themes:主题template：模块tension：拉力，张力tutorial：辅导资料toggle：切换 UVvisible：可见的validate：验证方法vertical 竖直的visited 访问过的 Wwidgets:小部件wetland：湿地wipe：擦除 XYZ]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Markdown]]></title>
      <url>%2F2017%2F03%2F29%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Markdown简介 Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档，然后转换成格式丰富的HTML页面。 —— 维基百科 正如您在阅读的这份文档，它使用简单的符号标识不同的标题，将某些文字标记为粗体或者斜体，创建一个链接或一个脚注[^demo]。下面列举了几个高级功能，更多语法请按Ctrl + /查看帮助。 代码块12345678910@requires_authorizationdef somefunc(param1='', param2=0): '''A docstring''' if param1 &gt; param2: # interesting print 'Greater' return (param2 - param1 + 1) or Noneclass SomeClass: pass&gt;&gt;&gt; message = '''interpreter... prompt''' LaTeX 公式可以创建行内公式，例如 $\Gamma(n) = (n-1)!\quad\forall n\in\mathbb N$。或者块级公式： $$ x = \dfrac{-b \pm \sqrt{b^2 - 4ac}}{2a} $$ 表格 Item Value Qty Computer 1600 USD 5 Phone 12 USD 12 Pipe 1 USD 234 流程图12345678st=&gt;start: Starte=&gt;endop=&gt;operation: My Operationcond=&gt;condition: Yes or No?st-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op 以及时序图: 123Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks! 提示：想了解更多，请查看流程图语法以及时序图语法。 复选框使用 - [ ] 和 - [x] 语法可以创建复选框，实现 todo-list 等功能。例如： [x] 已完成事项 [ ] 待办事项1 [ ] 待办事项2 注意：目前支持尚不完全，在印象笔记中勾选复选框是无效、不能同步的，所以必须在马克飞象中修改 Markdown 原文才可生效。下个版本将会全面支持。 [^demo]: 这是一个示例脚注。请查阅 MultiMarkdown 文档 关于脚注的说明。 限制： 印象笔记的笔记内容使用 ENML 格式，基于 HTML，但是不支持某些标签和属性，例如id，这就导致脚注和TOC无法正常点击。 脚注示例：]]></content>
    </entry>

    
  
  
</search>
